------------------------------------------------
TODO: https://trello.com/b/0Z1oVdg9/under-london
------------------------------------------------
I don't know whether I prefer keeping the list here or on Trello.
Trello is nice, but it's ALL THE WAY OVER THERE in a different program! (Which requires my internet to work...)

Handy emojis: âœ” âœ– â„¢ ðŸ’¡

Notes for searching:
	@Speed - Thing could be faster
	@Size - Thing could use less memory
	@Copypasta - Copy-pasted code, should probably be factored together
	@Cleanup - Stuff that needs investigating/organising, when it's convenient

------------------------------------------------

Renderer optimisation!
âœ” Remove the need for sorting, push draw everything in order
- Switch to a flat memory push-buffer instead of an array of RenderItems
- Things other than RenderItems!
	- Set the shader/texture/whatever
	- Can we combine the world/ui buffers too???? probably not but maybe.
	- Text, which has setup data and then a stream of chars & locations
	- We deal with grids a lot, some kind of sped-up thing for that would be good,
		either as "define a grid and then the colours of the cells" or "here is a mesh with a bunch of vertices". The latter is more general (and works for terrain!) but the former is simpler. Maybe both though!
	- Put all terrain in a single texture and set up a texture mesh per chunk!
- Maybe get rid of the overlayRenderItems thing, if we can

Speed up debug system?

Speed up text rendering!
- Maybe try that crazy "pass text as a single renderitem" idea?
	- Maybe that should be abstracted a little into a "draw a bunch of stuff together" feature. eg, Terrain could use something similar
- Possibly replace all floats in text-rendering with integers, and just produce floats at the very end for the actual renderitems. Everything is always done in whole-pixels anyway, and that should be a chunk faster.
	- calculateTextSize() could return V2I, etc. That's quite a deep rabbit hole though!
- Use u8s for RenderItem colours instead of V4? That'd divide the memory requirements for a colour by 4! Though, it's a bit tricky to know how that'll affect everything.

Add newline support to .text files!

Maybe String should use a constructor, so I stop making uninitialised-string-memory mistakes?

BuildingCatalogue:
- Store which menu a building is in, in a queryable way

SECTORS:
âœ” OK, new plan: Rather than have Sectors contain everything, it's easier to reason about things if we split everything into Layers like we already were doing, and then individual layers can organise their data into sectors or however they want, and their sectors can be different sizes or whatever. This means we can pick and choose where sectors do or don't make the most sense, and stick to a simpler flat 2D where we can.
	- I do think we want a standard set of tools for dealing with sector data, because connectivity and stuff is going to be similar in several cases.
âœ” Should we make sector internal data 1D arrays instead of 2D? Would make iterating the whole thing easier, but we'd want a helper function for getting the correct index. OR, we could union{} it maybe?
âœ” Power network
	âœ” Move power-network stuff out of City.h entirely? Put everything in PowerLayer, and make it manage its own sectors? Separating the different systems would be nice, though at the same time it might make it more awkward/less efficient to access stuff. Not sure... I think I'm going to try it though.
		âœ” Related, we can probably take the City* arg out of a lot of the internal PowerLayer functions.
		- Maybe we should even go oop-style and make things member functions? IDK.
	âœ” Rather than users calling recalculatePowerConnectivity(), have them mark a world area as dirty, and then the next time power updates, it checks for dirty regions and recalculates as necessary. At first it'll just be a "somethingIsDirty" bool or something, but later if we add local recalculation, we don't need to change the user code!
ðŸ’¡ THINK: Is there some way of making the network graph calculation work by making small changes instead of having to recompute the whole thing?
	- When recalculating the groups in a sector, do the "edge-of-sector border" checks, to find connected outside ones. We could detect network merges easily (a group is connected to other-sector groups with different networks) but splits are hard, I'm not sure how we could do that.
	- RESEARCH GRAPH THEORY STUFF!
		- An edge that will split the graph in two is called a "bridge". https://stackoverflow.com/questions/1566967/checking-if-removing-an-edge-in-a-graph-will-result-in-the-graph-splitting
		- Probably we want to store the graph itself, and track if a powergroup is a "bridge" as we go. That way, We know when we remove it that this has happened, and can rebuild only the networks that were connected to it. (Or maybe trigger a full rebuild, but at least we'd know that it's needed! If a powergroup isn't a bridge, we don't need to do anything, except update the connected powergroups so they know it was removed, and recalculate if they themselves are now bridges.)
- Road network
	- Similar stuff to how power works, so figure that out first
- Terrain
	- Terrain mesh? That's kind of a side issue
	- Also a side-issue, but combine all terrain into a single texture! That'll dramatically reduce draw calls.
âœ” Buildings
	âœ” findBuildingsInRectangle(), which returns some kind of temporary, iterable array.
	âœ” Add flags to ^ so we can request buildings whose ORIGIN is in the rectangle, and maybe some other requirements (eg, must carry power)
- Zones
	- Desirability per zone type
		- (later, make this per *spawn* type, which is more specific)
		- Desirability is used to prioritise new developments
	- Empty zone locations in sectors? (Do we even need those caches when we can just iterate through the 256 tiles in a sector pretty quickly? I guess one nice thing with keeping those lists is we can start at a random one, but we could still do that with tile iteration - just start at a random x,y instead of at 0,0 and cycle through them all.
		- Possible option: zone-per-tile be a struct with a zone type and flags, including "isOccupied", "isNearRoad" etc.
- Statistics
	- Jobs
	- Population
- Data
	- Land value
	- Pollution
	- Fire
	- Crime
	- Fire coverage
	- Police coverage
	- Traffic density

Tidy up the types/maths files, so that I can ACTUALLY FIND THINGS.
- Maybe color/v4 should be separate types?
- I'm sure I can think of other things too!

------------------------------------------------

Things to work on next maybe:
- Power stations and connectivity and consumption?
- Zones actually spawn stuff
- Maintain a graph of the power network, so we can recalculate a small portion when things change instead of rebuilding the whole thing
	- I think we already have enough information actually? PowerNetwork keeps a list of its Groups, and when we change a sector, only 3 things can happen: 1) nothing, 2) splitting a network into multiple parts, or 3) merging networks.
		Detecting 3) is easy - just see if all the boundaries of the group are the same network. If not, it's a merge!
		Detecting 2) is harder, not sure about that.
		Detecting 1) is just a case of realising neither 2 or 3 happened!
	- Related to this, we'd want to put networks in a structure that keeps their indices rather than rearranging them when adding/removing networks. (Because merging networks simply would involve moving all the groups from B into A, which would leave a gap at B's index.) I'm starting to want this structure more and more so I'd better implement it!
- Break the world into Sectors, each of which handles local information. (Power, path connectivity etc)
	- Transport, power, water, and probably other things, all rely heavily on a flood-fill connectivity check to know what parts of the city are relevant, and it's expensive to recalculate the entire map any time something changes. If we break this into two parts, within-chunk and between-chunks, we'd only need to recalculate at most a single chunk, and then the sectors graph itself. The downside is this is more complicated.
	- This means each sector would have its own list of PowerGroups, etc. That starts to get messy memory-wise, I don't think something like that would work with our MemoryArena approach. IDK, maybe we could be really sloppy and allocate tons of them? Or put all those things in a central place? Actually that makes more sense.
	- This also goes towards a few "nice to have" things, like expandable or infinite maps that stream sectors in and out as you move around, or multi-threaded simulation processing (calculate the power network for several sectors simultaneously).
	- Took me WAY TOO LONG to find this: Tynan Sylvester's description of Rimworld's region system: https://www.youtube.com/watch?v=RMBQn_sg7DA
		- OK, so his works differently to how I remembered - regions are not a strict grid. They don't find their neighbours spatially, but by using a global hash of the (x, y, direction and length) of each edge.
		- Each region knows which connectivity group ("room") it is part of, by direct pointer to the Room struct.
		- Modifying a region just involves deleting it and rebuilding it, and possibly adjusting the connections of its neighbours.
		- When two rooms become connected, (determined by a new, no-region tile having different rooms in neighbouring regions,) it calculates which has fewer regions, and makes those part of the larger room. That means no global recalculation!
		- I guess there must be some global table of which regions are contained within each grid square, for finding them in those cases? IDK. I guess you could just query that information from the tiles.
	- Rimworld's is highly specialised for spatial navigation. In our case, our different things (roads, power, etc) would require separate regions for each one. Maybe that's OK?
		- Maybe a hybrid - world is broken down into regular-sized sectors, eg 16x16. (Maybe not 16x16 if we're using it for hash purposes! 15 or a prime number might be better then.) Each one contains some number of road regions, and power regions, etc. It also keeps some statistics, like how many jobs and residents are inside it. It knows which buildings are in it. It could even cache the sprites inside it, eg a single "mesh" for the terrain. It also has flags, eg "there are valid empty R zones", "contains industry", or "there's a fire", which would speed up searches for things. 
	- Other stuff we could put in sectors:
		- List of service buildings whose areas of effect cover part of this sector, by service type. (Health, fire, police etc)
- Record the max building w or h somewhere so we can be smarter about how wide a margin of Sectors around the edge we check when querying buildings withing an area. (eg calculateDemolitionCost()) Currently we check ALL the Sectors that are up or left!


Data structure ideas I had late last night:
- Buildings array:
	Slots store whether they're empty or full. (Bitfield in the array chunk?)

    When removing one, just mark that slot empty.

    This way, building IDs (or anything else using that array type's indices) are constant. No need to update the id-by-tile array, or later, any other systems that might refer to a building. (Impressionable style walkers need an origin building, or SimCity citizens need a home and a workplace.) Also, this is necessary for inspection windows!

    Inserting into the array would require some walking, but we can keep track of the "earliest free slot index", which should reduce that a lot. (When you fill the slot, walk until you find another free one. When freeing a slot, if it's earlier than the current earliest index, replace that index.)

    I mean, maybe we want a different data structure than what I've described, but still, constant IDs are a must!

    Also probably want to consider what structure best suits other cases too, rather than just using Array always. Eg, ring buffers might be good sometimes.

Arrays stuff
- Try to remove all "dynamic" uses of Array<>, because it's bad. Replace with ChunkedArray for now.
- Main issue is, how do we sort ChunkedArrays?
	- I guess the best idea would be to take advantage of the chunks rather than letting them be a weakness. Maybe some variation on a Merge Sort? (Sort the items within each chunk, then combine them by walking the chunks simultaneously.) Though, that gets compilcated because of the variable (and possibly very large) number of chunks, and because we'd need an extra set of chunks to put the results in. (Could use temp memory, maybe that's OK?)

BUG: We get frame hitching at almost regular intervals. Profiling says it's caused by renderBuffer() sometimes taking twice as long. Need to identify this!
	It's not just rendering code taking twice as long, it's some other seemingly random (but consistent) functions too. I really don't know why.
	Possibly it's updateInput() now? OK yeah it's SDL_PumpEvents() which takes ages sometimes because of polling joysticks. It's fixed for SDL 2.0.10 which isn't out yet. 2.0.10 is going to fix ALL my problems, apparently.

Problem: The new pixel-art shader is great, but the edges of coloured rectangles (and possibly textured ones though it's harder to tell?) still flicker because they're always full pixels. Ideally we'd be able to smooth those out too. Maybe just switch to MSAA to fix that if I can't find/figure-out a shader solution. (It seems like we can't determine from a shader whether a fragment is on the edge or not.)
	Maybe we could draw coloured rectangles by using a plain white texture with a 1px transparent border, then doing funky things with the UVs??? So that the edge of the polygon isn't coloured, and the visible edge is handled by the awesome shader. That could be cool.

------------------------------------------------

THE PLAN:

This project was way too directionless for too long, so we're now aiming for a city-building game along the lines of Simcity. Zone things, build roads and services, try and balance the budget, etc. 2D graphics, probably a square grid rather than isometric (at least to start with). 

------------------------------------------------

Zoning
- We need some kind of "RCI demand" source/calculation. Probably a simple one for now because we don't have anything to simulate really, but we need *something*.
	- A reasonable one would include: available jobs or workers, tax rate, average land value.
- Every so often, pump the "spawn buildings" function that places a number of zoned buildings within zones, to approximately match what is demanded.
- Spawning buildings looks for empty zones that match criteria like distance to roads, and prioritises highly-desirable places.
	- Eventually we'd probably want a more efficient way to find those zones. Maybe keep a list of empty zone coordinates and their land value, or something like that.

Split the game code from the platform code
- Compile win32_main.cpp rather than main.cpp
- platform handles the renderer, input and memory.
- game has a single entry point function that's run once per frame.
- Related, we could do with more clearly separating the various systems, it's all a confusing, coupled, spaghetti mess right now.

GUI
- BUG: Text alignment doesn't work when the text wraps onto multiple lines! Each line should align itself horizontally. (So, a multi-line wrapped text with ALIGN_H_CENTRE should have each line centred!)
âœ” Convert Tooltips to a special kind of Window, so that we can reuse the fancy window code.
	âœ” Window flag for following the mouse
	âœ” Remove Tooltip style
	âœ” Remove tooltip code
	âœ” Make tooltips not be an "active" window, so they don't render other windows inactive!
- Convert Toasts (nÃ©e UI-Messages) to use windows too
	- This is somewhat more involved....
	- Multiple toasts can exist at once. I'm thinking each new one pushes all the previous ones up.
	- After an amount of time, they fade out.
	- So, probably keep Toasts in a separate array to Windows, because they work in a special way. Still use the WindowProc/Context stuff for convenience, but don't deal with them in updateAndRenderWindows(). So, also no need for a special WinFlag!
	- Remove UIMessage styles

Audio!
- Probably use SoLoud, rather than SDL_mixer: http://sol.gfxile.net/soloud/

Asset system:
- Ability to reload an individual file
- Detect filesystem changes and reload the files that change
	- Includes being a bit smart about dependant files. eg if a building texture was used, but after the building defs reload, they no longer use that texture, it could be unloaded? But honestly, keeping it around is way simpler and our memory requirements are going to be tiny anyway.
	- If a file gets deleted, what happens?
- There's a 96-byte memory leak when we reload the assets, and I'm not sure why.
- Replace sdl_image with our own loader so we can control where the memory comes from!
	- see https://github.com/spurious/SDL-mirror/blob/HEAD/src/stdlib/SDL_malloc.c
	- Looks like I need to update my version of SDL. Actually, worse than that, it was added AFTER 2.0.9 which is the current release version.
- Fancier memory management, if needed:
	- (We only need to worry about this if our asset memory usage gets high.
		If not, keep the current "load everything" system!)
	- reload asset, just free() then malloc() again!
		- Optimisation: Don't reallocate if it's the exact same size.
	- Keep a memory limit, track the current size of all loaded assets.
	- If we cross the limit, evict the least-recently-used asset.
	- Track evictions so we can monitor it and see if it's misbehaving.
- Asset packer of some kind. Maybe just creates an assets table?
- Text assets compiled in some way so we don't need a string lookup?
	- https://blog.thimbleweedpark.com/text_lock
	- BETTER: https://ourmachinery.com/post/localization-in-the-machinerys-ui/
- Audio when we have that!
- Sprite Atlas:
	- Take individual sprite .png files and pack them together into a single texture.
	- Pad them with a 1px border equal to whatever the edge pixel of the sprite was.
	- Output the atlas info to a file.
	- Asset system reads the atlas and uses it to populate Sprite assets.
- Asset Packs:
	- Assets can be grouped together into a "pack", and then we can specify to load a certain pack. This means not having to put all assets in memory at once.
	- At a basic level, we'd have a "preload" pack, which is loaded first, and provides what's needed to display a loading screen.
	- This could then be used for assets tied to a specific game level, if we *have* levels, or similar things like if you can have cities in different regions or planets with different terrain art, etc.
	- If we're going to evict assets at the end of a level though, we'd need to track which assets are associated with each pack - and some assets could be in multiple ones, potentially. Unless we make it a requirement that each asset only goes in one pack somehow? IDK.
	- A pack would probably just be defined in a text file. Lines of `type shortname.blah`

Better profiling
- If we record start/end events instead of just execution-durations, then we can reconstruct the stack. That would let us see which function CALLS are taking the most time, instead of just "function X takes a while".
- Maybe put the analysis system on a separate thread so that it doesn't disturb the game so much?

String HashTable!
- MeowHash???
- Maybe MurmurHash? https://en.wikipedia.org/wiki/MurmurHash
- Other hashes: http://www.cse.yorku.ca/~oz/hash.html

Console:
- Console eats all input events while it is open?
- Automatic parameter type checking? That might be crazy though.

Return false for isKeyPressed() etc, when the key is a printable character and we have a text input active?

Unicode stuff:
- 2-stage table for properties, will save space! Not sure if I need that, but thought it was sensible to put the link here in case I do. https://www.strchr.com/multi-stage_tables
- Check text is valid utf8 as it enters the program (so, when user enters it, or we read it from a file.)
	- Could maybe convert it to utf32 while we're at it? Would save time on lookups...

BUGS:
- Unloading Fraps does something funny with our Window reference, causing a crash.

FULLSCREEN!
- It's weird and buggy right now. Probably want to do the FULLSCREEN_DESKTOP flag, with special case code to make it centred on the screen and make sure input works.


---------------------------------------------
NOTES:
---------------------------------------------

Simcity Classic features:
(Can play it online at http://micropolis.mostka.com/ )
	Code at https://github.com/simhacker/micropolis
	A decent guide to how it works at https://github.com/SimHacker/micropolis/blob/wiki/InsideTheSimulator.md
	If we want to rip sprites from it, a good folder of PNGs is https://github.com/jason17055/micropolis-java/tree/master/graphics
R/C/I
	Zones! You plop a square down, but then it can be built in sections.
		I think I'll do drag-rect zones instead
	Demand! Formula is probably very simple
Demolish
Forest
Water
Roads
	Roads are placed by dragging a line, then release to place it all.
Fire/Police department buildings and coverage
	(seems to affect a plus-shap covering 5 8x8 tile chunks.)
Power stations and power lines
	Power lines need to exist "on top" of roads. How do we handle this? Maybe a building that's both, and we special-case place it when the player tries to place one on top of the other.
Water, bridges
Fires
Rails
Disasters?
	Flooding
Budget (control tax rate, transport/fire/police funding)
Query tool
Data views:
	Land value
	Crime
	Fire
	Pollution
	Traffic density
	Power connectivity
	Fire coverage
	Police coverage
Pause/resume/speed controls
Map generator

Notes:
Simcity 4 map sizes: 64x64 (~1km), 128x128 (~2km), 256x256 (~4km)
(Simcity 3000 map size info is harder to find, but apparently the largest is also 256x256 tiles)

SC3K does indeed model individual power networks, not just "is it connected to a power station" and "is the total of consumption < total production".

-------------------------------------------------

BUILD:

For future reference, here's the build system config (which I'm no longer using) for sublime text 3:
{
	"shell_cmd": "build.bat",
	"working_dir": "${file_path}",
	"file_regex": "^(...*?)[(]([0-9]*)[)]",
	"shell": true,
	"encoding": "gb2312"
}
Took me WAY TOO LONG to make that work.
